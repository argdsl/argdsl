/*
 * generated by Xtext 2.28.0
 */
package arg.serializer;

import Ardsl.AllInstances;
import Ardsl.ArdslPackage;
import Ardsl.Arithmetic;
import Ardsl.Attribute;
import Ardsl.AttributeValue;
import Ardsl.Binary;
import Ardsl.BitMasks;
import Ardsl.Collision;
import Ardsl.Connection;
import Ardsl.ConstantValue;
import Ardsl.Constraints;
import Ardsl.Force;
import Ardsl.Game;
import Ardsl.GamePad;
import Ardsl.Graphic;
import Ardsl.GraphicClass;
import Ardsl.Not;
import Ardsl.ObjAttribute;
import Ardsl.ObjInit;
import Ardsl.Ontological;
import Ardsl.Physic;
import Ardsl.PhysicBody;
import Ardsl.PhysicChange;
import Ardsl.PhysicClass;
import Ardsl.Reference;
import Ardsl.Rule;
import Ardsl.ScoreSystem;
import Ardsl.Trigger;
import Ardsl.Versions;
import arg.services.ArgGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ArgSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ArgGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ArdslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ArdslPackage.ALL_INSTANCES:
				sequence_AllInstances(context, (AllInstances) semanticObject); 
				return; 
			case ArdslPackage.ARITHMETIC:
				sequence_Arithmetic(context, (Arithmetic) semanticObject); 
				return; 
			case ArdslPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ArdslPackage.ATTRIBUTE_VALUE:
				sequence_AttributeValue(context, (AttributeValue) semanticObject); 
				return; 
			case ArdslPackage.BINARY:
				sequence_Binary(context, (Binary) semanticObject); 
				return; 
			case ArdslPackage.BIT_MASKS:
				sequence_BitMasks(context, (BitMasks) semanticObject); 
				return; 
			case ArdslPackage.CLASS:
				sequence_Class(context, (Ardsl.Class) semanticObject); 
				return; 
			case ArdslPackage.COLLISION:
				sequence_Collision(context, (Collision) semanticObject); 
				return; 
			case ArdslPackage.CONNECTION:
				sequence_Connection(context, (Connection) semanticObject); 
				return; 
			case ArdslPackage.CONSTANT_VALUE:
				sequence_ConstantValue(context, (ConstantValue) semanticObject); 
				return; 
			case ArdslPackage.CONSTRAINTS:
				sequence_Constraints(context, (Constraints) semanticObject); 
				return; 
			case ArdslPackage.FORCE:
				sequence_Force(context, (Force) semanticObject); 
				return; 
			case ArdslPackage.GAME:
				sequence_Game(context, (Game) semanticObject); 
				return; 
			case ArdslPackage.GAME_PAD:
				sequence_GamePad(context, (GamePad) semanticObject); 
				return; 
			case ArdslPackage.GRAPHIC:
				sequence_Graphic(context, (Graphic) semanticObject); 
				return; 
			case ArdslPackage.GRAPHIC_CLASS:
				sequence_GraphicClass(context, (GraphicClass) semanticObject); 
				return; 
			case ArdslPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case ArdslPackage.OBJ_ATTRIBUTE:
				sequence_ObjAttribute(context, (ObjAttribute) semanticObject); 
				return; 
			case ArdslPackage.OBJ_INIT:
				sequence_ObjInit(context, (ObjInit) semanticObject); 
				return; 
			case ArdslPackage.ONTOLOGICAL:
				sequence_Ontological(context, (Ontological) semanticObject); 
				return; 
			case ArdslPackage.PHYSIC:
				sequence_Physic(context, (Physic) semanticObject); 
				return; 
			case ArdslPackage.PHYSIC_BODY:
				sequence_PhysicBody(context, (PhysicBody) semanticObject); 
				return; 
			case ArdslPackage.PHYSIC_CHANGE:
				sequence_PhysicChange(context, (PhysicChange) semanticObject); 
				return; 
			case ArdslPackage.PHYSIC_CLASS:
				sequence_PhysicClass(context, (PhysicClass) semanticObject); 
				return; 
			case ArdslPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case ArdslPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case ArdslPackage.SCORE_SYSTEM:
				sequence_ScoreSystem(context, (ScoreSystem) semanticObject); 
				return; 
			case ArdslPackage.TRIGGER:
				sequence_Trigger(context, (Trigger) semanticObject); 
				return; 
			case ArdslPackage.VERSIONS:
				sequence_Versions(context, (Versions) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns AllInstances
	 *     AllInstances returns AllInstances
	 *
	 * Constraint:
	 *     type=EString
	 * </pre>
	 */
	protected void sequence_AllInstances(ISerializationContext context, AllInstances semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.ALL_INSTANCES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.ALL_INSTANCES__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAllInstancesAccess().getTypeEStringParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Arithmetic
	 *     Arithmetic returns Arithmetic
	 *
	 * Constraint:
	 *     (left=Value op=ArithmOps right=Value)
	 * </pre>
	 */
	protected void sequence_Arithmetic(ISerializationContext context, Arithmetic semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.ARITHMETIC__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.ARITHMETIC__LEFT));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.ARITHMETIC__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.ARITHMETIC__OP));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.ARITHMETIC__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.ARITHMETIC__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticAccess().getLeftValueParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getArithmeticAccess().getOpArithmOpsEnumRuleCall_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getArithmeticAccess().getRightValueParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns AttributeValue
	 *     AttributeValue returns AttributeValue
	 *
	 * Constraint:
	 *     (class=EString attribute=EString)
	 * </pre>
	 */
	protected void sequence_AttributeValue(ISerializationContext context, AttributeValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.ATTRIBUTE_VALUE__CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.ATTRIBUTE_VALUE__CLASS));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.ATTRIBUTE_VALUE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.ATTRIBUTE_VALUE__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeValueAccess().getClassEStringParserRuleCall_0_0(), semanticObject.getClass_());
		feeder.accept(grammarAccess.getAttributeValueAccess().getAttributeEStringParserRuleCall_2_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         type=EString 
	 *         min=EInt 
	 *         max=AttributeMax 
	 *         default=Constant 
	 *         isParam?='isParam'? 
	 *         isKey?='isKey'? 
	 *         readOnly?='readOnly'?
	 *     )
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Binary
	 *     Binary returns Binary
	 *
	 * Constraint:
	 *     (left=Condition op=LogicOps right=Condition)
	 * </pre>
	 */
	protected void sequence_Binary(ISerializationContext context, Binary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.LOGIC_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.LOGIC_OP__LEFT));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.BINARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.BINARY__OP));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.BINARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryAccess().getLeftConditionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBinaryAccess().getOpLogicOpsEnumRuleCall_3_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getBinaryAccess().getRightConditionParserRuleCall_5_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BitMasks returns BitMasks
	 *
	 * Constraint:
	 *     (collision+=[Class|EString] collision+=[Class|EString]* contact+=[Class|EString] contact+=[Class|EString]*)
	 * </pre>
	 */
	protected void sequence_BitMasks(ISerializationContext context, BitMasks semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Class returns Class
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (attributes+=Attribute attributes+=Attribute*)? 
	 *         (references+=Reference references+=Reference*)? 
	 *         abstract?='abstract'? 
	 *         noSCN?='invisible'?
	 *     )
	 * </pre>
	 */
	protected void sequence_Class(ISerializationContext context, Ardsl.Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Collision returns Collision
	 *
	 * Constraint:
	 *     (classA=[Class|EString] classB=[Class|EString] action=[Trigger|EString])
	 * </pre>
	 */
	protected void sequence_Collision(ISerializationContext context, Collision semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.COLLISION__CLASS_A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.COLLISION__CLASS_A));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.COLLISION__CLASS_B) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.COLLISION__CLASS_B));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.COLLISION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.COLLISION__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollisionAccess().getClassAClassEStringParserRuleCall_1_0_1(), semanticObject.eGet(ArdslPackage.Literals.COLLISION__CLASS_A, false));
		feeder.accept(grammarAccess.getCollisionAccess().getClassBClassEStringParserRuleCall_3_0_1(), semanticObject.eGet(ArdslPackage.Literals.COLLISION__CLASS_B, false));
		feeder.accept(grammarAccess.getCollisionAccess().getActionTriggerEStringParserRuleCall_5_0_1(), semanticObject.eGet(ArdslPackage.Literals.COLLISION__ACTION, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connection returns Connection
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         type=EString 
	 *         color=EString 
	 *         textColor=EString 
	 *         decorator=EString 
	 *         decoratorPos=EString 
	 *         pattern=EString 
	 *         width=EDouble 
	 *         position=EString
	 *     )
	 * </pre>
	 */
	protected void sequence_Connection(ISerializationContext context, Connection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONNECTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONNECTION__NAME));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONNECTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONNECTION__TYPE));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONNECTION__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONNECTION__COLOR));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONNECTION__TEXT_COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONNECTION__TEXT_COLOR));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONNECTION__DECORATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONNECTION__DECORATOR));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONNECTION__DECORATOR_POS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONNECTION__DECORATOR_POS));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONNECTION__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONNECTION__PATTERN));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONNECTION__WIDTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONNECTION__WIDTH));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONNECTION__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONNECTION__POSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConnectionAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConnectionAccess().getTypeEStringParserRuleCall_4_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConnectionAccess().getColorEStringParserRuleCall_6_0(), semanticObject.getColor());
		feeder.accept(grammarAccess.getConnectionAccess().getTextColorEStringParserRuleCall_8_0(), semanticObject.getTextColor());
		feeder.accept(grammarAccess.getConnectionAccess().getDecoratorEStringParserRuleCall_10_0(), semanticObject.getDecorator());
		feeder.accept(grammarAccess.getConnectionAccess().getDecoratorPosEStringParserRuleCall_12_0(), semanticObject.getDecoratorPos());
		feeder.accept(grammarAccess.getConnectionAccess().getPatternEStringParserRuleCall_14_0(), semanticObject.getPattern());
		feeder.accept(grammarAccess.getConnectionAccess().getWidthEDoubleParserRuleCall_16_0(), semanticObject.getWidth());
		feeder.accept(grammarAccess.getConnectionAccess().getPositionEStringParserRuleCall_18_0(), semanticObject.getPosition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns ConstantValue
	 *     ConstantValue returns ConstantValue
	 *
	 * Constraint:
	 *     value=Constant
	 * </pre>
	 */
	protected void sequence_ConstantValue(ISerializationContext context, ConstantValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONSTANT_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONSTANT_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantValueAccess().getValueConstantParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Constraints returns Constraints
	 *
	 * Constraint:
	 *     (
	 *         planes=Planes 
	 *         overlapping?='overlaps' 
	 *         sizeMin=EDouble 
	 *         sizeMax=EDouble 
	 *         xToOriginPos=EDouble 
	 *         yToOriginPos=EDouble 
	 *         zToOriginPos=EDouble 
	 *         rotation=EInt
	 *     )
	 * </pre>
	 */
	protected void sequence_Constraints(ISerializationContext context, Constraints semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONSTRAINTS__PLANES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONSTRAINTS__PLANES));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONSTRAINTS__OVERLAPPING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONSTRAINTS__OVERLAPPING));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONSTRAINTS__SIZE_MIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONSTRAINTS__SIZE_MIN));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONSTRAINTS__SIZE_MAX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONSTRAINTS__SIZE_MAX));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONSTRAINTS__XTO_ORIGIN_POS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONSTRAINTS__XTO_ORIGIN_POS));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONSTRAINTS__YTO_ORIGIN_POS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONSTRAINTS__YTO_ORIGIN_POS));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONSTRAINTS__ZTO_ORIGIN_POS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONSTRAINTS__ZTO_ORIGIN_POS));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.CONSTRAINTS__ROTATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.CONSTRAINTS__ROTATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintsAccess().getPlanesPlanesEnumRuleCall_1_0(), semanticObject.getPlanes());
		feeder.accept(grammarAccess.getConstraintsAccess().getOverlappingOverlapsKeyword_2_0(), semanticObject.isOverlapping());
		feeder.accept(grammarAccess.getConstraintsAccess().getSizeMinEDoubleParserRuleCall_4_0(), semanticObject.getSizeMin());
		feeder.accept(grammarAccess.getConstraintsAccess().getSizeMaxEDoubleParserRuleCall_6_0(), semanticObject.getSizeMax());
		feeder.accept(grammarAccess.getConstraintsAccess().getXToOriginPosEDoubleParserRuleCall_8_0(), semanticObject.getXToOriginPos());
		feeder.accept(grammarAccess.getConstraintsAccess().getYToOriginPosEDoubleParserRuleCall_10_0(), semanticObject.getYToOriginPos());
		feeder.accept(grammarAccess.getConstraintsAccess().getZToOriginPosEDoubleParserRuleCall_12_0(), semanticObject.getZToOriginPos());
		feeder.accept(grammarAccess.getConstraintsAccess().getRotationEIntParserRuleCall_14_0(), semanticObject.getRotation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Force returns Force
	 *
	 * Constraint:
	 *     (name=EString gesture=Gesture (xVector=EDouble yVector=EDouble zVector=EDouble)?)
	 * </pre>
	 */
	protected void sequence_Force(ISerializationContext context, Force semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GamePad returns GamePad
	 *
	 * Constraint:
	 *     (name=EString trigger=[Trigger|EString])
	 * </pre>
	 */
	protected void sequence_GamePad(ISerializationContext context, GamePad semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.GAME_PAD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.GAME_PAD__NAME));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.GAME_PAD__TRIGGER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.GAME_PAD__TRIGGER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGamePadAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGamePadAccess().getTriggerTriggerEStringParserRuleCall_2_0_1(), semanticObject.eGet(ArdslPackage.Literals.GAME_PAD__TRIGGER, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Game returns Game
	 *
	 * Constraint:
	 *     (
	 *         start=EString 
	 *         win=EString 
	 *         lose=EString 
	 *         score=ScoreSystem 
	 *         (actionsTriggers+=Trigger actionsTriggers+=Trigger*)? 
	 *         (collisions+=Collision collisions+=Collision*)? 
	 *         (gamepad+=GamePad gamepad+=GamePad*)? 
	 *         (objInit+=ObjInit objInit+=ObjInit*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Game(ISerializationContext context, Game semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GraphicClass returns GraphicClass
	 *
	 * Constraint:
	 *     (ontoClass=[Class|EString] versions+=Versions versions+=Versions* constraints=Constraints)
	 * </pre>
	 */
	protected void sequence_GraphicClass(ISerializationContext context, GraphicClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Graphic returns Graphic
	 *
	 * Constraint:
	 *     (classes+=GraphicClass classes+=GraphicClass*)
	 * </pre>
	 */
	protected void sequence_Graphic(ISerializationContext context, Graphic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Not
	 *     Not returns Not
	 *
	 * Constraint:
	 *     left=Condition
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.LOGIC_OP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.LOGIC_OP__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getLeftConditionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjAttribute returns ObjAttribute
	 *
	 * Constraint:
	 *     (attribute=[Attribute|EString] value=EString)
	 * </pre>
	 */
	protected void sequence_ObjAttribute(ISerializationContext context, ObjAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.OBJ_ATTRIBUTE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.OBJ_ATTRIBUTE__ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.OBJ_ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.OBJ_ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjAttributeAccess().getAttributeAttributeEStringParserRuleCall_0_0_1(), semanticObject.eGet(ArdslPackage.Literals.OBJ_ATTRIBUTE__ATTRIBUTE, false));
		feeder.accept(grammarAccess.getObjAttributeAccess().getValueEStringParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjInit returns ObjInit
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         class=[Class|EString] 
	 *         posX=PosOrCamera 
	 *         posY=PosOrCamera 
	 *         posZ=PosOrCamera 
	 *         rotation=EInt? 
	 *         (attribute+=ObjAttribute attribute+=ObjAttribute*)? 
	 *         (rules+=Rule rules+=Rule*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ObjInit(ISerializationContext context, ObjInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Ontological returns Ontological
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         classes+=Class 
	 *         classes+=Class* 
	 *         graphic=Graphic 
	 *         physic=Physic 
	 *         game=Game
	 *     )
	 * </pre>
	 */
	protected void sequence_Ontological(ISerializationContext context, Ontological semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PhysicBody returns PhysicBody
	 *
	 * Constraint:
	 *     (
	 *         mass=EDouble 
	 *         bodyType=BodyType 
	 *         charge=EDouble 
	 *         friction=EDouble 
	 *         rollingFriction=EDouble 
	 *         restitution=EDouble 
	 *         damping=EDouble 
	 *         angularDamping=EDouble
	 *     )
	 * </pre>
	 */
	protected void sequence_PhysicBody(ISerializationContext context, PhysicBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__MASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__MASS));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__BODY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__BODY_TYPE));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__CHARGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__CHARGE));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__FRICTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__FRICTION));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__ROLLING_FRICTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__ROLLING_FRICTION));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__RESTITUTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__RESTITUTION));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__DAMPING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__DAMPING));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__ANGULAR_DAMPING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.PHYSIC_BODY__ANGULAR_DAMPING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPhysicBodyAccess().getMassEDoubleParserRuleCall_1_0(), semanticObject.getMass());
		feeder.accept(grammarAccess.getPhysicBodyAccess().getBodyTypeBodyTypeEnumRuleCall_3_0(), semanticObject.getBodyType());
		feeder.accept(grammarAccess.getPhysicBodyAccess().getChargeEDoubleParserRuleCall_5_0(), semanticObject.getCharge());
		feeder.accept(grammarAccess.getPhysicBodyAccess().getFrictionEDoubleParserRuleCall_7_0(), semanticObject.getFriction());
		feeder.accept(grammarAccess.getPhysicBodyAccess().getRollingFrictionEDoubleParserRuleCall_9_0(), semanticObject.getRollingFriction());
		feeder.accept(grammarAccess.getPhysicBodyAccess().getRestitutionEDoubleParserRuleCall_11_0(), semanticObject.getRestitution());
		feeder.accept(grammarAccess.getPhysicBodyAccess().getDampingEDoubleParserRuleCall_13_0(), semanticObject.getDamping());
		feeder.accept(grammarAccess.getPhysicBodyAccess().getAngularDampingEDoubleParserRuleCall_15_0(), semanticObject.getAngularDamping());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PhysicChange returns PhysicChange
	 *
	 * Constraint:
	 *     (
	 *         action=Action 
	 *         class=[Class|EString]? 
	 *         object=EString 
	 *         position=Position? 
	 *         scale=EDouble? 
	 *         attribute=EString? 
	 *         changeValue=EInt? 
	 *         force=[Force|EString]?
	 *     )
	 * </pre>
	 */
	protected void sequence_PhysicChange(ISerializationContext context, PhysicChange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PhysicClass returns PhysicClass
	 *
	 * Constraint:
	 *     (ontoClass=[Class|EString] physicBody=PhysicBody (forces+=Force forces+=Force*)? bitMasks=BitMasks?)
	 * </pre>
	 */
	protected void sequence_PhysicClass(ISerializationContext context, PhysicClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Physic returns Physic
	 *
	 * Constraint:
	 *     (classes+=PhysicClass classes+=PhysicClass*)
	 * </pre>
	 */
	protected void sequence_Physic(ISerializationContext context, Physic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         containtment=EString? 
	 *         min=EInt 
	 *         max=EInt 
	 *         target=EString 
	 *         opposite=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (action=[Trigger|EString] condition=Condition)
	 * </pre>
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.RULE__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.RULE__ACTION));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.RULE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.RULE__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRuleAccess().getActionTriggerEStringParserRuleCall_1_0_1(), semanticObject.eGet(ArdslPackage.Literals.RULE__ACTION, false));
		feeder.accept(grammarAccess.getRuleAccess().getConditionConditionParserRuleCall_3_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ScoreSystem returns ScoreSystem
	 *
	 * Constraint:
	 *     (start=EInt finish=NoLimit lives=EInt)
	 * </pre>
	 */
	protected void sequence_ScoreSystem(ISerializationContext context, ScoreSystem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.SCORE_SYSTEM__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.SCORE_SYSTEM__START));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.SCORE_SYSTEM__FINISH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.SCORE_SYSTEM__FINISH));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.SCORE_SYSTEM__LIVES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.SCORE_SYSTEM__LIVES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScoreSystemAccess().getStartEIntParserRuleCall_1_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getScoreSystemAccess().getFinishNoLimitParserRuleCall_3_0(), semanticObject.getFinish());
		feeder.accept(grammarAccess.getScoreSystemAccess().getLivesEIntParserRuleCall_5_0(), semanticObject.getLives());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Trigger returns Trigger
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         action=BasicActions? 
	 *         message=EString? 
	 *         scoreChange=EInt? 
	 *         timeTrigger=EInt? 
	 *         (physicChanges+=PhysicChange physicChanges+=PhysicChange*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Trigger(ISerializationContext context, Trigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Versions returns Versions
	 *
	 * Constraint:
	 *     (name=EString URL=EString)
	 * </pre>
	 */
	protected void sequence_Versions(ISerializationContext context, Versions semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.VERSIONS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.VERSIONS__NAME));
			if (transientValues.isValueTransient(semanticObject, ArdslPackage.Literals.VERSIONS__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArdslPackage.Literals.VERSIONS__URL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVersionsAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVersionsAccess().getURLEStringParserRuleCall_2_0(), semanticObject.getURL());
		feeder.finish();
	}
	
	
}
